什么是版本控制？
   版本控制是一种在开发过程中用于管理我们对内容的修改历史，方便查看更改历史记录，备份
   以便恢复以前的版本的软件工程技术是一种用于管理多人协同开发项目的技术
   常见的版本控制工具：主要使用：Git、SVN 其他的有：CVS、VSS、TFS

版本控制分类：
	本地版本控制:适合个人使用，记录文件每次更新，如RCS
	集中版本控制（SVN）：是集中式版本控制系统，版本库是集中放在中央服务器的 
				优点：个人本地占用储存空间较小,只需要保存自己修改的内容即可
                 缺点：必须联网，所有的历史代码都存放在服务器中,一旦服务器崩溃,代码就会丢失,且不能找回
	分布式版本控制（Git）：所有版本信息仓库全部同步到本地的每个用户
						优点：可以离线，只要有一个用户的设备没有问题就可以恢复所有的数据
                          缺点：本地存储占用空间大
 Linux命令：     
          cd : 进入目录。
          cd . . 回退到上一个目录，直接cd进入默认目录
          pwd : 显示当前所在的目录路径。
          ls(ll):  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。（Mac只有ll）
          touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。
           rm:  删除一个文件, rm index.js 就会把index.js文件删除。
          mkdir:  新建一个目录,就是新建一个文件夹。
          rm -r :  删除一个文件夹, rm -r src 删除src目录
          mv ：移动文件, mv index.html src。 index.html 是我们要移动的文件, src 是目标文件夹,当然,
              这样写,必须保证文件和目标文件夹在同一目录下。
          reset 重新初始化终端/清屏。
          clear 清屏。
          history 查看命令历史。
          help 帮助。（Mac除外）
          exit 退出。
          #表示注释
          ls: 查看桌面的所有文件

git有四个工作区域：
   工作目录、暂存区、资源库、远程仓库
   在工作区可以通过git add . 添加到暂存区，可以通过git commit -m '名称'，添加到缓存区
   在缓存区可以通过git push 提交到远程仓库，6.拉取代码 git pull ，切换分支 git checkout xxxx(分支名称)，
   新建分支 git branch xxxxx(分支名称)
   通过git clone url(要克隆的地址)来克隆一个项目和整个历史代码

   所谓作用域通俗点讲就是变量的可作用范围。 一般有三种作用域。全局，函数，块。

        typeof：这种方法只能检测基本数据类型，null 和对象的不准
        instanceof：只要是基本数据类型检测就是false，只要是引用数据类型，并且右边是 Object 就是true，可以很好的区分是哪一大类型
        constructor：可以检查基本和引用数据类型，但是可以被修改，有一定的缺陷
        Object.prototype.toString.call()：这种方式是最准的，什么类型都可以检测
        Object.getPrototypeOf()：这种方法获取原型

js数据类型：基本数据类型：number、string、undefined、null、boolean、symbol、bigint
            引用数据类型【对象类型】：object、array、 function

Js中的数据类型转换有两种模式，一种是隐式转换（Number()），一种是显示转换(parseInt('字符串','进制')，parseFloat())

变量提升：var和函数声明都可以变量提升，函数声明的优先级高于var

作用域：作用域有全局作用域和函数作用域。全局作用域就是在哪里都能用，函数作用域就是只作用在函数内部
	
运算符：+-*/ && ||
    &&：从左到右依次判断，如果遇到一个假值，就返回假值，以后不再执行，否则返回最后一个真值；
    || ：为取真运算，从左到右依次判断，如果遇到一个真值，就返回真值，以后不再执行，否则返回最后一个假值
    大于(>)、小于(<)、大于等于(>=)、小于等于(<=)、相等(==)、全等(===)、不等(!=)、不全等(!==)等
    全等不光比较两者值是否相同，还比较变量类型是否相同；不全等也是一样

多维数组转一维数组我们可以用递归和es6的flat方法来进行转换
 使用递归的方式:
        let arr = [1, [2, [3, [4, [5, 6]]]]]
        let newArr = []
        function toArr(arr){
            for(let i = 0; i < arr.length; i++){
                if (Array.isArray(arr[i])) {
                    toArr(arr[i])
                }else {
                    newArr.push(arr[i])
                }
            }
        }
        toArr(arr)
        console.log(newArr);
 使用数组原型链上的方法flat:
        let arr1 = [1, 2, 3, [4, 5, 6], [11, 16], [14, 32]]
        console.log( arr1.flat() );

闭包：闭包就是函数嵌套函数，有权访问其他函数变量内部作用域的函数变量。
闭包的实现：
		function fn(){
            	let name = '你好';
            	return function() {
                	console.log(name);
            	}
        	}
        	let func = fn();
        	func();
上下文执行顺序：先执行同步任务，在执行异步任务；setTimeout是异步任务所以最后执行，其他按照顺序执行
 	let a = 'hello'
 	console.log(a);
 	function fn() {
     	console.log('你好');
     	setTimeout(()=>{
         		console.log('我是定时器');
     	},1000)
 	}
 	fn();
 	console.log('123');
数组的方法：
		  push-尾部添加--（返回新数组的长度，会改变原数组）
		  pop-末尾删除--（删除并返回数组的最后一个元素，若该数组为空，则返回undefined。会原数组改变，返回的是被删除的元素）
		  unshift-头部添加--（向数组的开头添加一个或多个元素，并返回新的数组长度。原数组改变）
		  shift-头部删除--（删除并返回数组的第一个元素，若该数组为空，则返回undefined。原数组改变）
		  concat-数组合并--（合并两个或多个数组，生成一个新的数组。原数组不变）
		  reverse-数组翻转--（将数组倒序。原数组改变）
		  sort-数组排序--（对数组元素进行排序，根据字符串UniCode码排序，原数组改变）
		  join-数组拼接--（将数组的每一项用指定字符连接形成一个字符串。默认连接字符为 “,” 逗号。）
		  toString-将数组转化为字符串
		  slice-数组截取（从哪里开始截几个，不改变原数组）
		  splice-数组删除（从哪里开始截取几个，返回的是截取到的数组，会改变原数组）
		  indexOf-数组查找（查找元素的位置，如果不存在就返回-1，存在就返回所在的下标，但是不能判断是否有NaN的元素）
		  includes-（可以判断是否包含某一元素，包含就是true，否则就是false，对NaN一样有效）
		  isArray-（判断是不是一个数组）
数组循环的方法：
		  map（创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果，不改变原数组，返回值是一个新的数组）
		  forEach（对数组的每个元素执行一次提供的函数。总是返回undefined。不改变原数组）
		  filter（对数组的每一项都进行过滤，返回符合条件的组成的数组，不会改变原数组）
		  find（遍历数组，找到第一个符合条件的项，并返回该项。否则返回undefined。不会改变数组）
		  findIndex（遍历数组找到第一个符合条件的项，并返回该项的索引值。否则返回-1。不会改变数组对象）
		  every（简单说就是看数组的每个元素是否符合要求，都符合则返回true，否则返回false）
		  some（是对数组中每一项运行指定函数，如果该函数对任一项返回true，则返回true。）
	
this的指向：在 js 中 this 不是固定不变的，它会随着执行环境的改变而改变。
		  要注意的是 this 取什么值，是在执行时确认的，定义时无法确认。
this 调用几种场景： 
		1.浏览器里，在全局范围内的 this 指向 window 对象； 
		2.在函数中，this 永远指向最后调用他的那个对象；
		3.构造函数中，this 指向 new 出来的那个新的对象；
		4.箭头函数中 this 比较特殊,箭头函数 this 为父作用域的 this，不是调用时的 this.
		要知道前四种方式,都是调用时确定,也就是动态的,而箭头函数的 this 指向是静态的,声明的时候就确定了下来；
改变this的方法：apply 、 call 、 bind 都可以改变this的指向；
		三者都可以改变函数的 this 对象指向
		三者第⼀个参数都是 this 要指向的对象，如果没有这个参数或参数为 undefined、 null ，则默认指向全局 window
		三者都可以传参，但是 apply 是数组形式传递，⽽ call 是以散落的方式传递，且 apply 和 call 是⼀次性传⼊参数，⽽ bind 可以分为多次传⼊
		bind 是返回绑定 this 之后的函数， apply 、 call 则是⽴即执⾏，bind需要调用；
原型、原型链：
		什么是原型？
			原型是function对象的一个属性，定义了构造函数创造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。
		什么是prototype?
   			显示原型，是函数（不包含箭头函数）本身存在的一个属性，他指向的是一个对象，即为原型对象。
		什么是 __ proto __ ?
			可以称为隐式原型，或者叫连接点。是对象的一个属性，它里面存储的是该构造函数的原型对象，即prototype.
		什么是构造函数？
			构造函数其实是一种特殊的函数，主要用来初始化对象，也就是为对象成员变量赋初始值，它总与new关键字一起使用
		什么是原型链？
			当我们访问一个实例（例如person）的属性或方法时，会先在当前`实例`上查找，若查找不到，会到`原型`上查找，若原型上查找不到，
			就到`原型的原型`上查找，若还是查找不到就指向`null`。
深浅拷贝：
		深拷贝拷贝的是值 浅拷贝拷贝的是地址
		深拷贝和浅拷贝的区别：
			1. 浅拷贝： 将原对象的引用直接赋给新对象，新对象只是原对象的一个引用，而不复制对象本身，新旧对象还是共享同一块内存
			2. 深拷贝： 创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用”，新对象跟原对象不共享内存，修改新对象不会改到原对象
			基本数据类型存储在栈中，引⽤数据类型存储在堆中
		浅拷贝的方法：Object.assign() ，解构赋值；深拷贝的方法：JSON.parse(JSON.stringify())、递归
js继承的几种方式：
			第一种：原型继承
				原型链继承是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，
				原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针。
				因为两个实例使用的是同一个原型对象。它们的内存空间是共享的，当一个发生变化的时候，另外一个也随之进行了变化，这就是使用原型链继承方式的一个缺点。
				优点：通过原型继承多个引用类型的属性和方法
				缺点：Sub原型变成了Super的实例，如果Super的实例某个属性是引用值，该引用值就会被应用到所有Sub创建的实例中去，会有污染问题。
			第二种：构造函数继承（借助 call）；
				构造函数实现继承的优缺点，它使父类的引用属性不会被共享，优化了第一种继承方式的弊端；
				缺点：只能继承父类的实例属性和方法，不能继承原型属性或者方法。
			第三种：组合继承（前两种组合）
				优点：集合了【原型继承】和【盗用构造函数继承】的优点
				缺点：存在效率问题，始终会被调用两次
			第四种：原型式继承
				ES5 里面的 Object.create 方法，这个方法接收两个参数：一是用作新对象原型的对象、二是为新对象定义额外属性的对象（可选参数）。
				缺点也很明显，多个实例的引用类型属性指向相同的内存，存在篡改的可能
				优点：对一个对象进行浅克隆创建另一个对象，同时继承该对象的原型属性
				缺点：无法判断实例的构造函数是父类还是子类
			第五种：寄生式继承
				使用原型式继承可以获得一份目标对象的浅拷贝，然后利用这个浅拷贝的能力再进行增强，添加一些方法，这样的继承方式就叫作寄生式继承。
				虽然其优缺点和原型式继承一样，但是对于普通对象的继承方式来说，寄生式继承相比于原型式继承，还是在父类基础上添加了更多的方法。
				优点：根据一个对象克隆创建另一个对象，并增强对象
				缺点：同【盗用构造函数继承】方法在每个实例上都要创建一遍
				注意：objectCopy不是原生接口，是自定义方法，对入参对象进行复制
			第六种：寄生组合式继承--实现：构造函数继承 + 原型式继承
				结合第四种中提及的继承方式，解决普通对象的继承问题的 Object.create 方法，我们在前面这几种继承方式的优缺点基础上进行改造，
				得出了寄生组合式的继承方式，这也是所有继承方式里面相对最优的继承方式
				优点：较好地实现了继承想要的结果，同时也减少了构造次数，减少了性能的开销
同步任务和异步任务：
			⾸先， JavaScript 是⼀⻔单线程的语⾔，意味着同⼀时间内只能做⼀件事，但是这并不意味着单线程就是阻塞，
			⽽实现单线程⾮阻塞的⽅法就是事件循环（event loop），在 JavaScript 中，所有的任务都可以分为同步任务和异步任务
			同步任务：⽴即执⾏的任务，同步任务⼀般会直接进⼊到主线程中执⾏
			异步任务：异步执⾏的任务，⽐如 ajax ⽹络请求， setTimeout 定时函数等 碰到异步任务会进入任务队列进行等待
   					异步执行的时机是同步代码执行完了 异步任务准备好（比如计时器到时间了 ajax 请求成功了）才会执行异步任务；
					异步任务 又分为宏任务微任务---在异步任务中 微任务先执行 宏任务后执行
   					宏任务：ajax 请求， setTimeout/setInterval
   					微任务：promise.then()，nextTick
Event Loop：
			所有同步任务都在主线程上执行，形成一个执行栈
			主线程之外，还存在一个”任务队列”。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。
			一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。于是结束等待状态，进入执行栈，开始执行。
			主线程不断重复上面的第三步。
			主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为 Event Loop（事件循环）。只要主线程空了，
		    就会去读取”任务队列”，这就是 JavaScript 的运行机制。这个过程会循环反复。

let特点：
   1.变量不能重复声明(特指:当前作用域不能进行重复声明，
   在下一个作用域的时候可以重复声明)
   2. 块儿级作用域 3.不存在变量提升 4.不影响作用域链
链式写法：（let f = 521, g = 'iloveyou',h = [];）
 Const
特点:
   1.声明一个常量,切不可更改
   2.一般常量用大写(潜规则)
   3. 块儿级作用域
   4.对于数组和对象的元素修改,不算做对常量的修改，不会报错
   因为只是修改了内容，并没有修改指针

变量的解构赋值分为两种.
 数组解构
以下标来进行解构，有序结构，不能单独解构出一个值
 对象结构
以属性名来进行解构,可以单独解构任何一个属性 

作用域：作用域分为全局作用域和局部作用域（函数作用域和块级作用域（es6））
作用域链:
  作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。
  作用域就是一个独立的地盘，让变量不会外
  泄、暴露出去。也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。

扩展运算符的概念： 扩展运算符又叫三点运算符,可以用来展开与合并
扩展运算符的应用：
1.数组的合并 
 const kuaizi = ['王太利','肖央'];
 const fenghuang =['曾毅'，'玲花'];
 const allArray = [...kuaizi,...fenghuang]
 const allArray1 = kuaizi.concat(fenghuang)// 循环 push
2.数组的克隆
const sanzhihua = ['E','G' 'M'];
const sanyecao = [...sanzhihua];// ['E','G','M']// 
console.log(sanyecao);
3.将伪数组转为真正的数组
const divs = document.querySelectorAll('div');
const divArr = [...divs];

Symbol的值是唯的，用来解决命名冲突的问题
Symbol值不能和其他数据进行运算
Svmbol定义的对象属性不能使用for…in循环遍历,但是可以使用Reflect.ownkevs来获取对象的所有键名

promise函数
概念: promise函数是解决异步编程问题产生的,所谓 Promise ，简单说就是一个容器，
里面保存着某个未来才会结束的事件(通常是
一个异步操作)的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。
Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理
特点:
(1).对象的状态不受外界影响,有三种状态:pending(进行中)、fulfilled(已成功)和 rejected(已失败)
(2).一旦状态改变.就不会再变任何时候都可以得到这个结果，romise对象的状态改变，
只有两种可能:从 pendina变为fulfilled和从pending 变为 rejected 。
只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved(已
定型)。如果改变已经发生了，你再对Promise对象添加回调函数。
也会立即得到这个结果。这与事件(Event)完全不同。事件的
特点是，如果你错过了它，再去监听，是得不到结果的。

模板字符串：js在es6中新增了模板字符串（``）语法，作用：可以在字符串中换行，以及将变量和表达式插入字符串
对象的简化写法：
 let name ="赚钱" 
 let hope=function(){ 
 console.log('赚钱'); 
 } 
 const PERSION={ 
 name, 
 hope,} 
箭头函数：
写法：let a=()=>{}
箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。
箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数
箭头函数的 this 永远指向其上下文的 this ，任何方法都改变不了其指向，如 call() , bind() , apply()，
如果只有一个参数，（）可以省略只有一个返回值时return和{}可以省略
reset参数：
形式为 ： “...变量名” es6引入rest参数（形式为...变量名）用于获取函数的多余参数，以代替arguments对象的使用。
rest参数是一个数组，数组中的元素是多余得参数。reset参数之后不能再有其他参数，reset参数位置在尾参数，函数的length 不包括 reset参数
function add(...arg){ }
add(1,2,3)

获取DOM节点的方法：
1.通过id获取
          document.getElementById（“id属性值”）
          特点：根据ID值获取元素，返回元素对象；(id唯一)
2.通过标签名获取
          document.getElementsByTagName(“标签名字”);；
         特点：标签名字获取元素,返回来的是一个伪数组,里面保存了多个的DOM对象；
3.通过name值
         document.getElementsByName(“name属性的值”) 
         根据name属性的值获取元素,返回来的是一个伪数组,里面保存了多个的DOM对象
4.通过class
         document.getElementsByClassName(“类样式的名字”)；
         根据类样式的名字来获取元素,返回来的是一个伪数组,里面保存了多个的DOM对象
5.通过选择器
        document.querySelector(“选择器的名字”);
        根据选择器获取元素,返回来的是一个元素对象
6. 通过所有选择器
       document.querySelectorAll(“选择器的名字”)
       据选择器获取元素,返回来的是一个伪数组,里面保存了多个的DOM对象
7.特殊元素获取
       doucumnet.body
       返回body元素对象
8. HTML元素获取
       document.documentElement
       html元素对象
伪数组：
具有length属性
按照索引的方式存储数据
不具有数组的push，pop等方法

伪数组和数组的区别：
相同点：都具有length属性和索引元素
不同点：伪数组不可以直接使用数组的方法，不能改变长度
伪数组转为数组：
1.for循环
2.数组.slice.call()
3.Array.prototype.slice.call()
4.es6的Array.form()
5.es6的扩展运算符（有兼容性问题）

arguments:arguments只能在函数内使用，在函数外是undefined，
同时arguments是一个对象，只是恰好属性名是数字，刚好可以使用数组的下标。
或者理解为类数组，有数组的length属性和下标取值属性
当不确定有多少参数传递的时候，用arguments来获取。
arguments其实是当前函数的一个内置对象。数组元素作为函数的参数。
arguments对象中存储了传递的所有实参。
arguments的展示形式是一个伪数组，可以遍历。
arguments对象和Function是分不开的。因为arguments这个对象不能显式创建。
arguments只在非箭头函数中存在，箭头函数中的arguments会从父级作用域中继承





