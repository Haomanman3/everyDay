<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 实现继承的方法

        //    1.原型继承 
        // function Super(){
        //         this.a=1
        //     }
        //     Super.prototype.say=function() {
        //         console.log('哈哈哈');
        //     }
        //     function Sub(){}
        //     Sub.prototype=new Super();
        //     const test=new Sub()
        //     console.log(test.say);//ƒ () { console.log('哈哈哈');  }

        // function Super(){
        //     this.a=[1,2]
        // }
        // function Sub() {}
        // Sub.prototype = new Super();
        // const test1=new Sub();
        // test1.a.push(3)
        // const test2=new Sub();
        // console.log(test2.a);//[1, 2, 3]

        //2.盗用构造函数
        // let Super=function() {
        //     this.a=1
        // }
        // let Sub=function() {
        //     Super.call(this)
        //     this.b=2
        // }
        // const test=new Sub()
        // console.log(test);//Sub {a: 1, b: 2}

        //3.组合继承
        // function Super() {
        //     this.a = [1, 2]
        // }
        // Super.prototype.say = function () {
        //     console.log('哈哈哈');
        // }

        // function Sub() {
        //     Super.call(this);
        //     this.b = 2
        // }
        // Sub.prototype = new Super()
        // const test1=new Sub()
        // console.log(test1.say);//ƒ () { console.log('哈哈哈'); }
        // test1.a.push(3)
        // console.log(test1.a);//[1, 2, 3]
        // const test2=new Sub()
        // console.log(test2.a);//[1, 2]

        // 原型式继承
        // es5继承
        // const obj={a:1}
        // function createObj(o){
        //     function Fn(){}
        //     Fn.prototype=o
        //     return new Fn()
        // }
        // const test=createObj(obj)
        // console.log(test);//Fn()

        // es6继承
        // const obj={a:1}
        // const test=Object.create(obj)
        // console.log(test);//{}

        // const obj={a:[1,2],b:2}
        // const test1=Object.create(obj)
        // const test2=Object.create(obj)
        // test1.a.push(3)
        // test1.b=3
        // console.log(test1.a,test2.a);// [1, 2, 3] [1, 2, 3]
        // console.log(test1.b,test2.b);//3 2

        // 5.寄生式继承

        // function createObj(o){
        //     let clone=objectCopy(o);
        //     clone.say=function() {
        //         console.log('哈哈哈');
        //     }
        //     return clone
        // }
        // const obj={a:1}
        // const test=createObj(obj)
        // console.log(obj,test);

        // 6.寄生式组合继承

        // function Super(){
        //     this.a=[1,2]
        // }
        // Super.prototype.say=function() {
        //     console.log('哈哈哈');
        // }
        // function Sub(){
        //     Super.call(this);
        //     this.b=2
        // }
        // Sub.prototype.say = Object.create(Super.prototype)
        // Sub.prototype.constructor = Sub;
        // const test=new Sub()
        // console.log(test);//属性原型（方法）都有
    </script>
    <script>
        // 实现继承的方法

        //    1.原型继承 
        // function Super(){
        //         this.a=1
        //     }
        //     Super.prototype.say=function() {
        //         console.log('哈哈哈');
        //     }
        //     function Sub(){}
        //     Sub.prototype=new Super();
        //     const test=new Sub()
        //     console.log(test.say);//ƒ () { console.log('哈哈哈');  }

        // function Super(){
        //     this.a=[1,2]
        // }
        // function Sub() {}
        // Sub.prototype = new Super();
        // const test1=new Sub();
        // test1.a.push(3)
        // const test2=new Sub();
        // console.log(test2.a);//[1, 2, 3]

        //2.盗用构造函数
        // let Super=function() {
        //     this.a=1
        // }
        // let Sub=function() {
        //     Super.call(this)
        //     this.b=2
        // }
        // const test=new Sub()
        // console.log(test);//Sub {a: 1, b: 2}

        //3.组合继承
        // function Super() {
        //     this.a = [1, 2]
        // }
        // Super.prototype.say = function () {
        //     console.log('哈哈哈');
        // }

        // function Sub() {
        //     Super.call(this);
        //     this.b = 2
        // }
        // Sub.prototype = new Super()
        // const test1=new Sub()
        // console.log(test1.say);//ƒ () { console.log('哈哈哈'); }
        // test1.a.push(3)
        // console.log(test1.a);//[1, 2, 3]
        // const test2=new Sub()
        // console.log(test2.a);//[1, 2]

        // 原型式继承
        // es5继承
        // const obj={a:1}
        // function createObj(o){
        //     function Fn(){}
        //     Fn.prototype=o
        //     return new Fn()
        // }
        // const test=createObj(obj)
        // console.log(test);//Fn()

        // es6继承
        // const obj={a:1}
        // const test=Object.create(obj)
        // console.log(test);//{}

        // const obj={a:[1,2],b:2}
        // const test1=Object.create(obj)
        // const test2=Object.create(obj)
        // test1.a.push(3)
        // test1.b=3
        // console.log(test1.a,test2.a);// [1, 2, 3] [1, 2, 3]
        // console.log(test1.b,test2.b);//3 2

        // 5.寄生式继承

        // function createObj(o){
        //     let clone=objectCopy(o);
        //     clone.say=function() {
        //         console.log('哈哈哈');
        //     }
        //     return clone
        // }
        // const obj={a:1}
        // const test=createObj(obj)
        // console.log(obj,test);

        // 6.寄生式组合继承

        // function Super(){
        //     this.a=[1,2]
        // }
        // Super.prototype.say=function() {
        //     console.log('哈哈哈');
        // }
        // function Sub(){
        //     Super.call(this);
        //     this.b=2
        // }
        // Sub.prototype.say = Object.create(Super.prototype)
        // Sub.prototype.constructor = Sub;
        // const test=new Sub()
        // console.log(test);//属性原型（方法）都有
    </script>
    <script>
        // 实现继承的方法

        //    1.原型继承 
        // function Super(){
        //         this.a=1
        //     }
        //     Super.prototype.say=function() {
        //         console.log('哈哈哈');
        //     }
        //     function Sub(){}
        //     Sub.prototype=new Super();
        //     const test=new Sub()
        //     console.log(test.say);//ƒ () { console.log('哈哈哈');  }

        // function Super(){
        //     this.a=[1,2]
        // }
        // function Sub() {}
        // Sub.prototype = new Super();
        // const test1=new Sub();
        // test1.a.push(3)
        // const test2=new Sub();
        // console.log(test2.a);//[1, 2, 3]

        //2.盗用构造函数
        // let Super=function() {
        //     this.a=1
        // }
        // let Sub=function() {
        //     Super.call(this)
        //     this.b=2
        // }
        // const test=new Sub()
        // console.log(test);//Sub {a: 1, b: 2}

        //3.组合继承
        // function Super() {
        //     this.a = [1, 2]
        // }
        // Super.prototype.say = function () {
        //     console.log('哈哈哈');
        // }

        // function Sub() {
        //     Super.call(this);
        //     this.b = 2
        // }
        // Sub.prototype = new Super()
        // const test1=new Sub()
        // console.log(test1.say);//ƒ () { console.log('哈哈哈'); }
        // test1.a.push(3)
        // console.log(test1.a);//[1, 2, 3]
        // const test2=new Sub()
        // console.log(test2.a);//[1, 2]

        // 原型式继承
        // es5继承
        // const obj={a:1}
        // function createObj(o){
        //     function Fn(){}
        //     Fn.prototype=o
        //     return new Fn()
        // }
        // const test=createObj(obj)
        // console.log(test);//Fn()

        // es6继承
        // const obj={a:1}
        // const test=Object.create(obj)
        // console.log(test);//{}

        // const obj={a:[1,2],b:2}
        // const test1=Object.create(obj)
        // const test2=Object.create(obj)
        // test1.a.push(3)
        // test1.b=3
        // console.log(test1.a,test2.a);// [1, 2, 3] [1, 2, 3]
        // console.log(test1.b,test2.b);//3 2

        // 5.寄生式继承

        // function createObj(o){
        //     let clone=objectCopy(o);
        //     clone.say=function() {
        //         console.log('哈哈哈');
        //     }
        //     return clone
        // }
        // const obj={a:1}
        // const test=createObj(obj)
        // console.log(obj,test);

        // 6.寄生式组合继承

        // function Super(){
        //     this.a=[1,2]
        // }
        // Super.prototype.say=function() {
        //     console.log('哈哈哈');
        // }
        // function Sub(){
        //     Super.call(this);
        //     this.b=2
        // }
        // Sub.prototype.say = Object.create(Super.prototype)
        // Sub.prototype.constructor = Sub;
        // const test=new Sub()
        // console.log(test);//属性原型（方法）都有
    </script>
</body>

</html>